---
categories:
- Teatime
date: "2016-04-20"
tags:
- continuous integration
title: "Teatime: Continuous Integration"
---
	
		<div class="entry-content">
		<p><em>Welcome back to Teatime! This is a weekly feature in which we sip tea and discuss some topic related to quality. Feel free to bring your tea and join in with questions in the comments section.</em></p>
<p><strong><em>Tea of the week: </em></strong><em><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwj-rY3Hn5jMAhXDs4MKHS4PDkwQFgg6MAA&amp;url=http%3A%2F%2Fwww.teavana.com%2Fus%2Fen%2Foprah-chai-collection&amp;usg=AFQjCNEje7d2jHEngtZWHKETdG4C8Z45bQ&amp;sig2=8AJHljAD1zwXAOLyb-WU0A&amp;bvm=bv.119745492,d.amc">Oprah Chai.</a> I expected this to be boring and gimmicky, but it was surprisingly bold, and a pleasant drink all-around. I tried it at a Starbucks before I bought some, which is a nice perk.</em><br />
<p><a href="/blog/teaset2pts.png" rel="attachment wp-att-116"><img loading="lazy" class="size-medium wp-image-116 aligncenter" src="/blog/teaset2pts-300x264.png" alt="teaset2pts" width="300" height="264" srcset="/blog/teaset2pts-300x264.png 300w, /blog/teaset2pts-768x676.png 768w,/blog/teaset2pts-1024x901.png 1024w, /blog/teaset2pts.png 1138w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<h2>Today&#8217;s Topic: Continuous Integration</h2>
<p>Today&#8217;s topic is continuous integration; much of it is adapted from a book called <a href="http://smile.amazon.com/Continuous-Delivery-Deployment-Automation-Addison-Wesley/dp/0321601912/ref=sr_1_1?ie=UTF8&amp;qid=1460986704&amp;sr=8-1&amp;keywords=continuous+delivery">Continuous delivery</a> by Jez Humble and David Farley. When I gave this talk, I gave a disclaimer that the book aims to start with the worst possible practices and walk them up to the best possible practices. Since my company is far from the worst possible state, a lot of the items were things we were already doing. I&#8217;d be interested to hear in the comments what you already do or don&#8217;t do.</p>
<h3>The Problem</h3>
<p>Here are some of the major problems in the industry that Humble and Farley saw when they sat down to write the book in 2011:</p>
<ul>
<li><strong>Delivering software is hard! </strong>Release day arrives; everyone&#8217;s tense, nervous. Nobody&#8217;s quite sure the product will even work, and nobody wants their part to be the bit that fails, putting them on the chopping block. We&#8217;ve got one shot at this launch, and if we botch it, we cost the company millions as customers go offline. Expect 3am phone calls from Operations &#8212; did development forget to write down a step in the process? Did someone forget to put a file in the build folder? Is all the SQL going to run first try? What if some of the data we thought was in prod has changed since we started developing? Are we really, really sure?</li>
<li><strong>Manual Testing Sucks, Period.</strong> It takes <em>forever</em> to manually test a product, and nobody&#8217;s ever quite sure we covered everything. How many bugs do you get where you&#8217;re asking yourself, &#8220;Didn&#8217;t they test this? How did this ever work?&#8221; It&#8217;s so obvious in hindsight when these things come in, but it&#8217;s customers finding them. And it takes weeks, months maybe, to run a full test cycle on a brand new app if it does anything more than CRUD. Oh, and performance testing? Manually? Eh, it seems fast enough, release it. Security testing? Who has time for this crap?</li>
<li><strong>&#8220;It worked in dev&#8221;</strong> <strong>syndrome</strong>. What are the differences between dev and prod? Can you name them all off the top of your head? When do you test in a production-like environment, and what are the differences between production-like and production? Who tested in dev? What did they test? Are you sure you understand how users will interact with your system? How many times do you get bugs where you ask yourself &#8220;Why did they even click that?!&#8221;</li>
<li><strong>No way to test deployment</strong>. The only truly prod-like servers are prod; the only process is &#8220;a person does a thing&#8221;. You can&#8217;t test people, and there&#8217;s always going to be turnover. How do you know they did it right? How can you audit their process, or improve on it? People aren&#8217;t exactly reliable, that&#8217;s why we invented machines ðŸ˜‰</li>
</ul>
<h3>The Principles</h3>
<p>So here&#8217;s what they came up with as guidelines to try and correct the system. These are necessary to pull yourself out of process hell and start building toward Continuous Integration:</p>
<ul>
<li><strong>Every Commit is a Release candidate</strong>. Every single one could potentially be released. If it adds value, and doesn&#8217;t break anything else, it&#8217;s ready to release. Whether it&#8217;s actually released is going to be up to the BA and/or PM, of course, but you don&#8217;t want to commit anything you know is broken, you&#8217;ll just waste everyone&#8217;s time. If you want the safety blanket of committing early and often, make a feature branch; when you merge that back in, it&#8217;s a release candidate.</li>
<li><strong>Repeatable, Reliable Release Process</strong>. Once you have that commit, you want a standardized process, on paper, that can be repeated with every release, no exceptions. If there ARE exceptions, you document those too, so they&#8217;re not exceptions anymore; things like rolling back a failed deployment should be a standard, repeatable process as well. We had one week where we accidentally re-promoted a broken release because I forgot to pull it out of the QA branch after it failed in production the week before. Needless to say, after I made a round of apologies, I documented that step as well!</li>
<li><strong>Automate all the things!</strong> Automate everything. The authors have never seen a release process that can&#8217;t be automated with sufficient work and ingenuity. After I gave this talk the first time, I embarked on a 6-month project to do just that, simplifying our convoluted multiple-branch SVN strategy into a flatter tree, and automating the deployment from Trunk. It took ages and it was painful to implement, but the new system is much more reliable, faster, and generally nicer to use.</li>
<li><strong>Keep everything in source control</strong>. The goal is to allow a new team member to come in, sit down at a brand new workstation, run a checkout, run a build script, and have a working environment. Yes, that includes the database. Yes, that includes the version of Coldfusion or Node or whatnot. Yes, that includes the Apache or Nginx configuration. It should be possible to see at a glance what version of the application and dependencies are on the servers. Node&#8217;s package.json is a great step toward that ideal</li>
<li><strong>If it hurts, do it more often</strong>. Example: Merging sucks. Merging more often, in smaller chunks, is easier than delaying until the end of the project to merge and resolve conflicts. Another example: releasing sucks. So instead of releasing huge products once a quarter, release them once a month, or once a week, or once a day, or once an hour&#8230;</li>
<li><strong>Build Quality In</strong> This idea comes from Lean: the earlier you find a bug, the cheaper it is to fix. We QA folks tend to know that, and our mantra becomes Test Early, Test Often. If you find a bug in your code before you commit it, that&#8217;s maybe ten minutes time to fix it, max. If you find it in QA, now the person who found the bug has to write a ticket, the PM has to triage it, you have to read it and understand it, maybe some more clarification  back and forth, then you have to hunt through the code to find the problem, and then you fix it. So now we&#8217;re looking at hours of time rather than minutes. And if the problem is found in production and we have to run through a whole release cycle? Plus the customers&#8217; time lost trying to work around the bug? A disaster. This is where unit testing and integration testing is super important.</li>
<li><strong>Done means release</strong><strong>d</strong> In Waterfall, &#8220;done&#8221; means &#8220;built, ready for testing&#8221;. In Agile, &#8220;done&#8221; means &#8220;ready to be released&#8221;, which means the developers don&#8217;t stop caring about something until it passes testing. DevOps goes one step beyond that: &#8220;done&#8221; means &#8220;released to production&#8221;. After all, what good is something that is beautifully crafted and passed all tests if the customer can&#8217;t use it yet? This ties into the next principle:</li>
<li><strong>Everyone is responsible for delivery</strong> In the Waterfall way, the developer builds a thing, tosses it over the wall to QA, and walks away, expecting other people to be responsible for getting it into prod. In the DevOps world, we&#8217;re all on the same team together: it doesn&#8217;t matter whose fault it is or what went wrong, everyone&#8217;s responsible for helping get the code safely into production. The developer should be on hand to chime in with his intimate knowledge of the code while the operations folks are trying to get things running.</li>
<li><strong>Continuous Improvement</strong> This is my favorite principle ðŸ™‚ The general flow of work should be: Plan, Do, Study, Act. Routinely, we should get together to ask &#8220;how could do this better next time?&#8221;. We should take controlled risks in order to improve our craft.</li>
</ul>
<h3>The Practices</h3>
<p>In order to support the above principles, the following practices need to be in place:</p>
<ul>
<li><strong>Use CI Software</strong>. We use Atlassian&#8217;s Bamboo to build and deploy changes. It makes 0 sense to have people do this manually; people are good at creative tasks, while computers are good at repetitive, boring tasks.</li>
<li><strong>Don&#8217;t break the build</strong> Run the tests before you commit; don&#8217;t commit if something&#8217;s broken. An intern once asked me, &#8220;404s aren&#8217;t real errors, right?&#8221;. He was so used to popping open the console and seeing a dozen 404 errors that he didn&#8217;t notice the one that mattered. We can&#8217;t just have errors sitting around in production that we ignore, or we train ourselves to ignore real errors too.</li>
<li><strong>Don&#8217;t move on until commit tests pass</strong> The CI server should be fast enough to give you feedback before you move on to another task; you should wait until you&#8217;re sure your commit is good before changing gears, so that if there&#8217;s something broken, you still have all the information you need loaded into your metaphorical RAM and don&#8217;t have to metaphorically swap pages to get to it.</li>
<li><strong>You break it, you fix it</strong> Take responsibility for your changes! If your commit breaks something else, it&#8217;s not the other author&#8217;s problem, it&#8217;s your problem, because you made the change. Pointing fingers is a bad habit to get into.</li>
<li><strong>Fail fast</strong> The authors suggest failing the build for slow tests. I agree, sheepishly; my functional tests are slow as heck, but I&#8217;m always trying to tighten the feedback loop and get developers information as rapidly as possible. They also suggest failing for linting issues, because they can lead to weird bugs later on. They suggest failing for architectural breaches, things like inline SQL when you have a stored-proc architecture, or other problems like that. The more you fail in dev, the less you fail in Prod.</li>
<li><strong>Deploy to prod-like environments</strong> You should be deploying to environments that mimic production before you get out of the testing cycle, to make sure it&#8217;s going to be a clean deploy.  More importantly, <em>what</em><em> </em>you deploy to that environment should be exactly, byte for byte, what you deploy to prod. With the new release process I&#8217;ve set up, that&#8217;s exactly what we do: we physically move the exact files, no building on the server anymore. Staging should be the exact same hardware, the same load balancing, the same OS configuration, the same application stack, with data in a known good state.</li>
</ul>
<p>&nbsp;</p>
<p>I know that was a lot of dense information this week, but hopefully it gave you a nice clear picture of the goal state you can work toward. Was it useful? Let me know in the comments!</p>

			</div><!-- .entry-content -->
