---
categories:
- Teatime
date: "2016-05-01"
tags:
- security
title: "Teatime: Intro to Security Testing"
---

	
		<div class="entry-content">
		<p><em>Welcome back to Teatime! This is a weekly feature in which we sip tea and discuss some topic related to quality. Feel free to bring your tea and join in with questions in the comments section.</em></p>
<p><strong><em>Tea of the week: </em></strong><em>It was my birthday this past Sunday; for my birthday some years ago, my grandmother bought me some <a href="http://www.teavana.com/us/en/tea/black-tea/black-dragon-pearl-black-tea-31397.html">Dragon Pearls</a> from Teavana, which instantly made my all-time favorites list. They&#8217;re expensive, but soooo worth it. </em><br />
<p><a href="/blog/teaset2pts.png" rel="attachment wp-att-116"><img loading="lazy" class="size-medium wp-image-116 aligncenter" src="/blog/teaset2pts-300x264.png" alt="teaset2pts" width="300" height="264" srcset="/blog/teaset2pts-300x264.png 300w, /blog/teaset2pts-768x676.png 768w,/blog/teaset2pts-1024x901.png 1024w, /blog/teaset2pts.png 1138w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<h2>Today&#8217;s topic: Intro to Security Testing</h2>
<p>This information was mostly adapted from the OWASP Testing Guide version 4, freely available at <a href="http://www.owasp.org">owasp.org</a>. OWASP (which stands for the Open Web Application Security Project) is the go-to resource for all things web security, and they provide a ton of free information. I highly recommend browsing their site.</p>
<h3>Principles</h3>
<p>The first section of their guide talks about some basic principles of security testing. Some of these are familiar to me as a QA professional, but some of them are a little more specialized. Here&#8217;s the ones I felt were important to discuss when I gave this talk in person:</p>
<ul>
<li><strong>There is no silver bullet</strong> No firewall setting or security scanner is foolproof; security testing is testing like anything else, and it requires a customized test plan for your needs and your application just like functional testing does. Security assessment software makes a great first-pass, but it is not in-depth or nearly as effective as a multi-part strategy. Security is a process, not a product.</li>
<li><strong>Think strategically, not tactically</strong> The patch-and-penetrate model generally results in failure; there&#8217;s always a window of vulnerability while you develop a patch for what you&#8217;ve found. Users may not be aware of the patch and may not apply it even if they are aware; often, they feel patching may break functionality in the application, especially if it&#8217;s heavily customizable like most ERP systems. We need to be more proactive about security, finding and patching issues before release instead of after.</li>
<li><strong>Test early, test often</strong> This applies to security as much as it does functional testing: integrating testing into the entire software life cycle is better than trying to squish it in near the end. Plan software with security in mind and you&#8217;ll end up with a more secure end product.</li>
<li><strong>Think  outside the box</strong> This is where testing skill comes in handy. A good functional tester will find alternate paths and error paths that a developer didn&#8217;t consider when they just tested the happy path; a good security tester will look at the application like a hacker rather than like an end user, finding odd sequences that may lead to exploits. Try to figure out what the developers may not have thought of or what assumptions they may have made.</li>
<li><strong>Use The Source, Luke!</strong> Black-box testing is only ever going to be so effective. This is one place where white-box testing really shines: you can find potential exploit sources much easier if you have some understanding of the source code, because exploits are usually very technical in nature. Where possible,  use static analysis on the code itself to search for vulnerabilities.</li>
<li><strong>Develop Metrics</strong> Metrics can be a very controversial topic, I know. Good metrics will show you if more training/education about security is required, if there is a security mechanism that is not well understood by the team, and if the number of problems is going up or down over time; they shouldn&#8217;t be directly tied to individual compensation or promotion decisions. OWASP has a project about developing good security metrics that can be helpful</li>
<li><strong>Document test results</strong> A formal record of the results is crucial. The record must make it clear to the business owner where the risks exist and what was done to mitigate them; it should also be clear to the developer where the exact location of the vulnerability is and what was the recommendation. Finally, the record should make it easy for another tester to replicate the results, much like a good scientific paper.</li>
</ul>
<h3>Techniques</h3>
<p>Here are some techniques that OWASP recommends for security testing:</p>
<ul>
<li><strong>Human review</strong> This can be done as part of a code review, or on its own. It can be simple and informal: simply ask the code author how something works and why it was done that way. This should follow the principle &#8220;trust but verify&#8221;: don&#8217;t assume that what you&#8217;re told is correct, but don&#8217;t be antagonistic either. This is the best way to find out if people understand the security implications of what they&#8217;re writing. OWASP has a good code review guide for this sort of thing.</li>
<li><strong>Threat Modelling</strong> is one of my favorites from this paper, but I&#8217;m an old-school &#8220;model first&#8221; kind of tester. The idea is that while creating a tech design, you can create a threat model using the following three steps. First, <em>decompose the application: </em>create use-cases, identify entry points, define and classify the assets that are at risk, and identify trust levels that represent access rights external entities should be granted. Secondly, <em>Determine and rank threats</em>: <em> </em>Rank the assets in order from most vulnerable to least vulnerable; identify possible threats and vulnerabilities; and rank the threats using a security risk model. Finally, <em>create mitigation strategies</em> and countermeasures for the threats identified.</li>
<li><strong>Penetration testing</strong><em>, </em>or &#8220;Hack yourself first&#8221; as they say. Generally,  you will try to hack your own application before release using black-box strategies. This is very useful for general networking threats, like firewall openings, but less so for web applications. It can be very cheap and fast, but it&#8217;s hard to customize this sort of thing enough to catch serious issues.</li>
</ul>
<h3>OWASP Top 10</h3>
<p>Finally, I wanted to run down the 2013 Top Ten list; this provides a guide to low-hanging fruit. Every developer in your organization should be familiar with what these vulnerabilities are and how to prevent against them, as they are the most common exploits.</p>
<ol>
<li><strong>Injection</strong>. This covers SQL Injection, but also LDAP, NoSQL, and XML injection, as well as similar types of injection attacks.</li>
<li><strong>Broken authentication and session management</strong> This covers guessable credentials, session IDs in the URL that can be guessed, session IDs that don&#8217;t time out or rotate, and credentials that are sent unencrypted so anyone can read them.</li>
<li><strong>Cross-Site Scripting (XSS)</strong> In the simplest form, this vulnerability occurs when user input is output to the page without being escaped first, which can lead to javascript execution if the user types certain data. This is the most widespread web application security flaw.</li>
<li><strong>Insecure direct object references</strong> This is where an authorized user can get access to data that they should not have access to by accessing it directly. For example, if your user has access to widget foo  but not widget bar, and they see that the URL says /edit?widget=foo, when they change that URL to read /edit?widget=bar, they should be denied access. Many applications do not check the authorization directly, instead relying on the fact that the menu does not offer widget bar to protect their data.</li>
<li><strong>Security Misconfiguration</strong> This is a broad category covering things like default accounts to the web server allowing remote management, unpatched flaws at any level, unprotected files or directories, et cetera. This can cover platform-level flaws, app-level flaws, database-level flaws, or even custom code that was misconfigured</li>
<li><strong>Sensitive Data Exposure</strong> This covers items like failing to encrypt sensitive data as it goes over the wire, allowing man-in-the-middle attacks to gain data without even having to hack the site. Always remember to use SSL protocol when transmitting sensitive data!</li>
<li><strong>Function-level access control</strong> This is like number 4 above, but for functions. If you can see widget foo at /view?widget=foo, you don&#8217;t necessarily have access to /edit?widget=foo; again, this needs to be checked at the function level. AJAX requests need to be secured as well; it&#8217;s easy enough to capture the response to a &#8220;GET&#8221; packet and re-submit it as a &#8220;POST&#8221; or a &#8220;DELETE&#8221; to see if the server allows editing.</li>
<li><strong>Cross-site Request Forgery</strong> An authenticated user visits a malicious site, which uses an image beacon to submit a request to your site. Because of the way browsers authenticate requests, the browser will check if your site has a cookie (which it does) and attach that to the request. This allows the specially-crafted image beacon to submit a malicious request and capture the data.</li>
<li><strong>Components with known vulnerabilities</strong> This covers things like using an old version of a web framework or failing to patch it, introducing the vulnerability into your site. This is very common with Java or Wordpress, as they are always releasing patches for security vulnerabilities.</li>
<li><strong>Unvalidated redirects and/or forwards</strong> Sometimes after the user performs an action, you want to forward them to another page; for example, if they were trying to access a secured resource, you might direct them to a login page, then back to the page they were trying to get to. If you do not validate the redirect, an attacker can craft a request to your login page that redirects the user to their own site after they log into what they are sure is a valid login page hosted on your domain. They may not realize they have left your site after they log in!</li>
</ol>
<p>This was sort of a whirlwind tour of security testing, but hopefully some of you found it helpful. Did you learn anything new? Let me know!</p>

			</div><!-- .entry-content -->