---
categories:
- Teatime
date: "2016-04-10"
tags:
- maintainability
- programming
title: "Teatime: Programming Paradigms"
---

	
		<div class="entry-content">
		<p><em>Welcome back to Teatime! This is a weekly feature in which we sip tea and discuss some topic related to quality. Feel free to bring your tea and join in with questions in the comments section.</em></p>
<p><strong><em>Tea of the week: </em></strong><em>Rootbeer </em><em>Rooibos from <a href="http://www.subrosatea.com/rooibos-and-herbal-tisanes-caffeine-free">Sub Rosa Tea</a>. A nice change from my typical tea-flavored-teas and chais, this fun, quirky tea really brightens up a dull day. </em><br />
<p><a href="/blog/teaset2pts.png" rel="attachment wp-att-116"><img loading="lazy" class="size-medium wp-image-116 aligncenter" src="/blog/teaset2pts-300x264.png" alt="teaset2pts" width="300" height="264" srcset="/blog/teaset2pts-300x264.png 300w, /blog/teaset2pts-768x676.png 768w,/blog/teaset2pts-1024x901.png 1024w, /blog/teaset2pts.png 1138w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<h2>Today&#8217;s Topic: Programming Paradigms</h2>
<p>Programming languages come in many forms, and are intended to be used in many different ways. Understanding the organization and design patterns that apply to your language helps considerably with maintainability. This stuff might be old hat to devs, but as more and more QA folks pick up a bit of programming for automation, it can be helpful to have a refresher.</p>
<h3>Procedural Code</h3>
<p>The very first thing we designed (programmable) computers to do was to take in a list of instructions and execute them. Fundamentally, that&#8217;s the heart of all programming; as such, everything&#8217;s built on the procedural code paradigm.</p>
<p>The next improvement we made was to add subroutines (sometimes called &#8220;functions&#8221;), small bits of code that could be executed as a single custom instruction. This provides code re-use as well as increased readability. Basically everything can be written this way, but it&#8217;s the primary paradigm for C, BASIC, Go, Python, and PHP.</p>
<h3>Object-Oriented Programming</h3>
<p>Object-oriented programming attempts to model the system as a series of discrete objects that both encapsulate data and contain the logic necessary to work with the data. The basic building block here is the <strong>object</strong>, which contains both <strong>properties</strong> (pieces of data) and <strong>methods </strong>(encapsulated bits of logic, much like subroutines). This is where you start to get your classic Design Patterns, like Singleton or Factory patterns.</p>
<p>Objects can be <strong>composed</strong>; a Cat object might contain a Skeleton object that has a list of bones and keeps track if any are broken.  Objects can also have <strong>inheritance</strong>, where one object fundamentally is another object but with added properties or methods; for example, a Cat object might inherit from a Mammal object the ability to nurse its young and be petted. In <strong>classical inheritance</strong>, you have a Class definition which explains what all objects of a given type look like, and specific instances created from that template; Classes inherit from other Classes. In <strong>prototypical inheritance</strong>, every object is a unique snowflake that can dynamically mix-in the properties of another object, much like how bacteria can incorporate the genes of other bacteria they swallow. Objects in this system inherit directly from other objects.</p>
<p>Primarily object-oriented languages include Java, Ruby, and C#. You know you&#8217;re dealing with an object-oriented language when you have to declare a Class with a Main method in order to provide a starting point for even a simple application.</p>
<h3>Functional Programming</h3>
<p>The basic building block in a pure Functional programming paradigm is the Function. This isn&#8217;t the same as a subroutine; instead, this is a mathematical function, or &#8220;pure function&#8221;. A pure function takes inputs and returns outputs, with no state, side effects, or other changes. Functions are immutable, and the values are immutable; for a given immutable input, a function returns an immutable output. Rather than have extensive loops and conditionals, you instead are expected to compose functions together until your data is in the state you expect it to be in. If you&#8217;ve ever heard of Map-Reduce, the famous algorithm from Google, this is functional programming (Map takes a set of data and applies a function to each element; Reduce takes a set of data into a function that composes it into a single value).</p>
<p>Primarily functional languages include Lisp, Haskell, F#, Clojure, and Scala.</p>
<h3>Event-Based Programming</h3>
<p>Event-driven programming was invented basically to handle the special case of GUIs. When you&#8217;re running a Graphical User Interface, you typically want to sit idle waiting for the user to perform an action before you respond to it. Rather than have every element on the screen poll to see if it&#8217;s been clicked every so often, you instead have an &#8220;event loop&#8221; that polls for any click anywhere. Different elements subscribe to specific events, such as &#8220;was a button clicked&#8221; or &#8220;did a request from the server complete&#8221; or whatnot.</p>
<p>Primarily event-driven languages include Node.JS. Javascript in general is an odd mix of Functional, Procedural, and Event-Driven code, with some Objects thrown in there for extra fun.</p>
<p>What paradigm are you most comfortable programming in? Have you tried all of the above? Let me know in the comments ðŸ™‚</p>
<p>&nbsp;</p>

			</div><!-- .entry-content -->